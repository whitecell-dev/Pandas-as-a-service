<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EDT Micro-Kernel Engine</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'SF Mono', 'Monaco', monospace; 
            background: #0a0a0a; 
            color: #e0e0e0;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        .header {
            border-bottom: 1px solid #333;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1 { 
            font-size: 24px; 
            color: #00ff88;
            margin-bottom: 10px;
        }
        .subtitle { color: #666; font-size: 14px; }
        
        .grid { 
            display: grid; 
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .panel {
            background: #111;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .panel h2 {
            color: #00ff88;
            font-size: 14px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .state-view {
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            color: #aaa;
            background: #0a0a0a;
            padding: 10px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .service-card {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 10px;
        }
        
        .service-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .service-title { 
            color: #fff; 
            font-weight: bold;
            font-size: 14px;
        }
        
        .service-type {
            background: #00ff88;
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .service-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-running { background: #00ff88; }
        .status-stopped { background: #ff4444; }
        
        .control-bar {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 12px;
        }
        
        button:hover { background: #00cc6a; }
        button:disabled { 
            background: #333; 
            color: #666;
            cursor: not-allowed;
        }
        
        .log {
            background: #0a0a0a;
            border: 1px solid #222;
            border-radius: 4px;
            padding: 10px;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'SF Mono', monospace;
        }
        
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-left: 2px solid transparent;
        }
        
        .log-info { border-left-color: #00ff88; color: #aaa; }
        .log-warn { border-left-color: #ffaa00; color: #ffaa00; }
        .log-error { border-left-color: #ff4444; color: #ff4444; }
        
        .metrics {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        .metric {
            background: #0a0a0a;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 20px;
            color: #00ff88;
            font-weight: bold;
        }
        
        .metric-label {
            font-size: 10px;
            color: #666;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .json-editor {
            width: 100%;
            min-height: 300px;
            background: #0a0a0a;
            color: #e0e0e0;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            font-family: 'SF Mono', monospace;
            font-size: 12px;
            resize: vertical;
        }

        .tab-bar {
            display: flex;
            gap: 2px;
            margin-bottom: 15px;
            background: #0a0a0a;
            padding: 5px;
            border-radius: 4px;
        }

        .tab {
            padding: 8px 16px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            color: #666;
            font-size: 12px;
        }

        .tab.active {
            background: #00ff88;
            color: #000;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≤ EDT Micro-Kernel Engine</h1>
            <div class="subtitle">Schema-driven execution with pluggable primitive handlers</div>
        </div>

        <div class="control-bar">
            <button id="startBtn">‚ñ∂Ô∏è Start</button>
            <button id="stopBtn">‚èπ Stop</button>
            <button id="tickBtn">‚ö° Tick Once</button>
            <button id="loadExampleBtn">üì¶ Load Example</button>
            <button id="validateBtn">‚úÖ Validate</button>
            <span style="margin-left: auto; color: #666; font-size: 12px;">
                Engine: <span id="engineStatus" style="color: #00ff88;">READY</span> | 
                Core: ~50 lines | 
                Handlers: Pluggable
            </span>
        </div>

        <div class="grid">
            <div class="panel">
                <h2>Services</h2>
                <div id="services"></div>
                <div class="metrics">
                    <div class="metric">
                        <div class="metric-value" id="totalServices">0</div>
                        <div class="metric-label">Services</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="runningServices">0</div>
                        <div class="metric-label">Running</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="tickCount">0</div>
                        <div class="metric-label">Ticks</div>
                    </div>
                    <div class="metric">
                        <div class="metric-value" id="eventCount">0</div>
                        <div class="metric-label">Events</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>State</h2>
                <div class="state-view" id="stateView"></div>
            </div>
        </div>

        <div class="panel">
            <h2>SPC Editor</h2>
            <div class="tab-bar">
                <div class="tab active" data-tab="spc">SPC Definition</div>
                <div class="tab" data-tab="schemas">Schemas</div>
                <div class="tab" data-tab="handlers">Handlers</div>
            </div>
            <textarea id="spcEditor" class="json-editor"></textarea>
        </div>

        <div class="panel">
            <h2>Event Log</h2>
            <div class="log" id="eventLog"></div>
        </div>
    </div>

    <script>
// ============================================================================
// HELPER FUNCTIONS (Must be defined first)
// ============================================================================

function applyRules(data, rules, context) {
    let result = JSON.parse(JSON.stringify(data));
    for (const rule of rules) {
        if (!rule.if || evalExpression(rule.if, { data: result, state: context?.state || {} })) {
            for (const [key, template] of Object.entries(rule.then || {})) {
                result[key] = templateObject(template, { data: result, state: context?.state || {} });
            }
        }
    }
    return result;
}

function evalExpression(expr, context) {
    try {
        const fn = new Function('data', 'state', 'row', `return ${expr}`);
        return fn(context.data, context.state, context.row);
    } catch {
        return null;
    }
}

function templateObject(obj, context) {
    if (typeof obj === 'string') {
        const match = obj.match(/^\{\{(.+?)\}\}$/);
        if (match) {
            return evalExpression(match[1].trim(), context);
        }

        return obj.replace(/\{\{(.+?)\}\}/g, (_, expr) => {
            const result = evalExpression(expr.trim(), context);
            return result !== null && result !== undefined ? result : '';
        });
    }

    if (Array.isArray(obj)) {
        return obj.map(item => templateObject(item, context));
    }

    if (typeof obj === 'object' && obj !== null) {
        const result = {};
        for (const [key, value] of Object.entries(obj)) {
            result[key] = templateObject(value, context);
        }
        return result;
    }

    return obj;
}

function pick(obj, fields) {
    const result = {};
    for (const field of fields) {
        if (obj.hasOwnProperty(field)) {
            result[field] = obj[field];
        }
    }
    return result;
}

// ============================================================================
// EDT MICRO-KERNEL ENGINE (~50 lines of core logic)
// ============================================================================

class EDTEngine {
    constructor() {
        this.spc = null;
        this.running = false;
        this.handlers = new Map();
        this.schemas = new Map();
        this.interval = null;
        this.metrics = { ticks: 0, events: 0 };
    }

    async tick() {
        if (!this.spc) return;
        
        const ctx = this.createContext();
        const results = [];

        for (const [id, service] of Object.entries(this.spc.services)) {
            if (service.status !== 'running') continue;
            
            const handler = this.handlers.get(service.type);
            if (!handler) {
                ctx.log('warn', `No handler for type: ${service.type}`);
                continue;
            }

            try {
                const schema = this.schemas.get(service.type);
                if (schema) this.validateService(service, schema);
                
                const result = await handler.run(id, service.spec, ctx);
                if (result) {
                    Object.assign(this.spc.state, result.patch || {});
                    if (result.events) results.push(...result.events);
                    service.lastRun = new Date().toISOString();
                }
            } catch (error) {
                const msg = error?.message || String(error);
                ctx.log('error', `Service ${id} failed: ${msg}`);
                this.spc.state[`${id}_error`] = msg;
            }
        }

        this.metrics.ticks++;
        this.metrics.events += results.length;
        this.render();
        return results;
    }

    createContext() {
        return {
            clock: () => new Date().toISOString(),
            state: this.spc.state,
            services: this.spc.services,
            hash: (...parts) => this.hash(parts),
            log: (level, msg, meta) => this.log(level, msg, meta),
            fetch: (url, opts) => fetch(url, opts).then(async r => {
                if (!r.ok) {
                    const body = await r.text().catch(() => '');
                    throw new Error(`HTTP ${r.status} ${r.statusText} @ ${url}${body ? ' ‚Äî ' + body.slice(0, 120) : ''}`);
                }
                return r.json();
            })
        };
    }

    register(handler) {
        this.handlers.set(handler.type, handler);
        this.log('info', `Registered handler: ${handler.type}`);
    }

    start() {
        if (!this.running) {
            this.running = true;
            this.interval = setInterval(() => this.tick(), 5000);
            this.log('info', 'Engine started');
            this.render();
            this.tick();
        }
    }

    stop() {
        if (this.running) {
            this.running = false;
            clearInterval(this.interval);
            this.log('info', 'Engine stopped');
            this.render();
        }
    }

    validateService(service, schema) {
        if (!service.id || !service.type || !service.spec) {
            throw new Error('Missing required fields');
        }
    }

    hash(parts) {
        const s = JSON.stringify(parts);
        const bytes = new TextEncoder().encode(s);
        let h = 2166136261 >>> 0;
        for (let b of bytes) { 
            h ^= b; 
            h = Math.imul(h, 16777619); 
        }
        return ('00000000' + h.toString(16)).slice(-8);
    }

    log(level, message, meta = {}) {
        const entry = document.createElement('div');
        entry.className = `log-entry log-${level}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        const logEl = document.getElementById('eventLog');
        if (logEl) {
            logEl.appendChild(entry);
            if (logEl.children.length > 100) {
                logEl.firstChild.remove();
            }
        }
    }

    render() {
        const servicesEl = document.getElementById('services');
        if (servicesEl) {
            servicesEl.innerHTML = '';
            
            let running = 0, total = 0;
            for (const [id, service] of Object.entries(this.spc?.services || {})) {
                total++;
                if (service.status === 'running') running++;
                
                const card = document.createElement('div');
                card.className = 'service-card';
                card.innerHTML = `
                    <div class="service-header">
                        <span class="service-title">${service.title || id}</span>
                        <span class="service-type">${service.type}</span>
                    </div>
                    <div>
                        <span class="service-status status-${service.status || 'stopped'}"></span>
                        <span style="color: #666; font-size: 11px;">
                            ${service.lastRun ? `Last run: ${new Date(service.lastRun).toLocaleTimeString()}` : 'Never run'}
                        </span>
                    </div>
                `;
                servicesEl.appendChild(card);
            }

            const totalEl = document.getElementById('totalServices');
            const runningEl = document.getElementById('runningServices');
            const tickEl = document.getElementById('tickCount');
            const eventEl = document.getElementById('eventCount');
            
            if (totalEl) totalEl.textContent = total;
            if (runningEl) runningEl.textContent = running;
            if (tickEl) tickEl.textContent = this.metrics.ticks;
            if (eventEl) eventEl.textContent = this.metrics.events;
        }
        
        const stateEl = document.getElementById('stateView');
        if (stateEl) {
            stateEl.textContent = JSON.stringify(this.spc?.state || {}, null, 2);
        }
        
        const statusEl = document.getElementById('engineStatus');
        if (statusEl) {
            statusEl.textContent = this.running ? 'RUNNING' : 'STOPPED';
            statusEl.style.color = this.running ? '#00ff88' : '#ff4444';
        }
    }
}

// ============================================================================
// PRIMITIVE HANDLERS (Pluggable modules)
// ============================================================================

const connectorHandler = {
    type: 'connector',
    async run(id, spec, ctx) {
        const { url, outputKey = `${id}_data`, rules } = spec;
        
        try {
            const finalUrl = url.replace(/\{\{(.+?)\}\}/g, (_, path) => {
                const val = path.trim().split('.').reduce((o, k) => o?.[k], ctx.state);
                if (val === undefined || val === null) {
                    throw new Error(`Missing template variable: ${path}`);
                }
                return encodeURIComponent(val);
            });
            
            const data = await ctx.fetch(finalUrl);
            
            let processed = data;
            if (rules?.rules) {
                processed = applyRules(data, rules.rules, ctx);
            }
            
            return {
                patch: { [outputKey]: processed },
                events: [{ name: 'connector.fetched', for: id, data: { url: finalUrl } }]
            };
        } catch (error) {
            const msg = error?.message || String(error);
            ctx.log('error', `Connector ${id} failed: ${msg}`);
            return {
                patch: { [`${id}_error`]: msg }
            };
        }
    }
};

const processorHandler = {
    type: 'processor',
    run(id, spec, ctx) {
        const { inputKey, outputKey = `${id}_output`, transform, pipes } = spec;
        const input = ctx.state[inputKey];

        if (!input) {
            return { patch: { [outputKey]: null } };
        }

        let result = input;

        if (transform) {
            result = applyRules(input, transform, ctx);
        }

        if (pipes) {
            for (const pipe of pipes) {
                if (pipe.select) {
                    result = Array.isArray(result)
                        ? result.filter(row => evalExpression(pipe.select, { row, state: ctx.state }))
                        : result;
                }
                if (pipe.project) {
                    result = Array.isArray(result)
                        ? result.map(row => pick(row, pipe.project))
                        : pick(result, pipe.project);
                }
                if (pipe.derive) {
                    if (Array.isArray(result)) {
                        result = result.map(row => {
                            const copy = { ...row };
                            for (const [k, expr] of Object.entries(pipe.derive)) {
                                copy[k] = evalExpression(expr, { data: row, state: ctx.state, row });
                            }
                            return copy;
                        });
                    } else if (typeof result === 'object' && result !== null) {
                        for (const [k, expr] of Object.entries(pipe.derive)) {
                            result[k] = evalExpression(expr, { data: result, state: ctx.state });
                        }
                    } else {
                        result = { value: result };
                        for (const [k, expr] of Object.entries(pipe.derive)) {
                            result[k] = evalExpression(expr, { data: result, state: ctx.state });
                        }
                    }
                }
            }
        }

        const patch = { [outputKey]: result };

        const persisted = [];
        try {
            if (result && typeof result === 'object') {
                const persistList = Array.isArray(spec.persist) ? spec.persist : [];
                for (const k of Object.keys(result)) {
                    const shouldPersist = k.startsWith('_') || persistList.includes(k);
                    if (shouldPersist) {
                        ctx.state[k] = result[k];
                        persisted.push(k);
                    }
                }
            }
        } catch (err) {
            ctx.log('error', `Processor ${id} persist failed: ${err?.message || err}`);
        }

        const events = [{ name: 'processor.computed', for: id }];
        if (persisted.length) {
            events.push({ name: 'processor.persisted', for: id, data: { persisted } });
        }

        return { patch, events };
    }
};

const monitorHandler = {
    type: 'monitor',
    run(id, spec, ctx) {
        const { checks = [], thresholds = {}, emit = 'onChange' } = spec;
        const results = {};
        
        for (const check of checks) {
            const data = ctx.state[check.dataKey];
            const value = evalExpression(check.expression, { data, state: ctx.state });
            
            if (value == null) {
                results[check.name] = { value: null, status: 'unknown' };
                continue;
            }
            
            const threshold = thresholds[check.name] || {};
            
            let status = 'normal';
            if (threshold.above !== undefined && value > threshold.above) status = 'critical';
            if (threshold.below !== undefined && value < threshold.below) status = 'critical';
            
            results[check.name] = { value, status, threshold };
        }
        
        const outputKey = `${id}_monitoring`;
        const prevResults = ctx.state[outputKey];
        const changed = JSON.stringify(prevResults) !== JSON.stringify(results);
        
        const shouldEmit = 
            emit === 'always' ||
            (emit === 'onChange' && changed) ||
            (emit === 'onTrue' && Object.values(results).some(r => r.status === 'critical'));
        
        return {
            patch: { [outputKey]: results },
            events: shouldEmit ? [{ 
                name: 'monitor.alert', 
                for: id, 
                data: results 
            }] : []
        };
    }
};

const adapterHandler = {
  type: 'adapter',
  async run(id, spec, ctx) {
    if (spec.kind !== 'webhook') return {};

    const input = spec.inputKey ? ctx.state[spec.inputKey] : {};
    const context = { data: input, state: ctx.state };

    const idempKey = spec.idempotency_key
       ? templateObject(spec.idempotency_key, { state: ctx.state, data: ctx.state.demo_data })
      : ctx.hash(id, ctx.clock());

    const dedupKey = `__sent_${ctx.hash(id, idempKey)}`;

    if (ctx.state[dedupKey]) {
      ctx.log('info', `Adapter ${id}: Skipped (idempotent)`);
      return {};
    }

    const body = spec.body ? templateObject(spec.body, { state: ctx.state, data: ctx.state.demo_data }) : {};

    try {
      ctx.log('info', `Adapter ${id}: Would send webhook to ${spec.url}`);
      return {
        patch: {
          [dedupKey]: ctx.clock(),
          [`${id}_last_sent`]: {
            timestamp: ctx.clock(),
            body,
            idempotency_key: idempKey
          }
        },
        events: [{ name: 'adapter.sent', for: id, data: { url: spec.url } }]
      };
    } catch (error) {
      const msg = error?.message || String(error);
      return { patch: { [`${id}_error`]: msg } };
    }
  }
};

const aggregatorHandler = {
    type: 'aggregator',
    run(id, spec, ctx) {
        const { inputKey, outputKey = `${id}_aggregated`, window, reduce } = spec;
        const input = ctx.state[inputKey];
        
        if (!input) return {};
        
        const windowKey = `__window_${id}`;
        const windowData = ctx.state[windowKey] || { items: [], start: ctx.clock() };
        
        windowData.items.push({ data: input, timestamp: ctx.clock() });
        
        const windowSizeMs = (window.size_sec || 30) * 1000;
        const now = new Date();
        windowData.items = windowData.items.filter(item => {
            return (now - new Date(item.timestamp)) < windowSizeMs;
        });
        
        let result = windowData.items;
        if (reduce?.emit) {
            switch (reduce.emit) {
                case 'latest':
                    result = windowData.items[windowData.items.length - 1]?.data;
                    break;
                case 'count':
                    result = windowData.items.length;
                    break;
                case 'all':
                    result = windowData.items.map(i => i.data);
                    break;
            }
        }
        
        return {
            patch: {
                [windowKey]: windowData,
                [outputKey]: result
            },
            events: [{ name: 'aggregator.window', for: id, data: { count: windowData.items.length } }]
        };
    }
};

// ============================================================================
// VAULT HANDLER - Secure secrets management
// ============================================================================
const vaultHandler = {
    type: 'vault',
    async run(id, spec, ctx) {
        const { provider, secrets = [], rotation_policy } = spec;
        
        // Simulated vault operations (in production, integrate with real vault providers)
        const vaultKey = `__vault_${id}`;
        const vaultData = ctx.state[vaultKey] || { secrets: {}, lastRotation: null };
        
        try {
            // Check if rotation is needed
            const needsRotation = rotation_policy && 
                (!vaultData.lastRotation || 
                 (new Date() - new Date(vaultData.lastRotation)) > (rotation_policy.interval_hours * 3600000));
            
            if (needsRotation) {
                ctx.log('info', `Vault ${id}: Rotating secrets per policy`);
                vaultData.lastRotation = ctx.clock();
            }
            
            // Store secret references (not actual secrets)
            for (const secretRef of secrets) {
                vaultData.secrets[secretRef] = {
                    ref: secretRef,
                    provider,
                    lastAccessed: ctx.clock()
                };
            }
            
            return {
                patch: {
                    [vaultKey]: vaultData,
                    [`${id}_status`]: {
                        provider,
                        secretCount: secrets.length,
                        lastRotation: vaultData.lastRotation,
                        healthy: true
                    }
                },
                events: [{
                    name: needsRotation ? 'vault.rotated' : 'vault.accessed',
                    for: id,
                    data: { provider, secretCount: secrets.length }
                }]
            };
        } catch (error) {
            const msg = error?.message || String(error);
            ctx.log('error', `Vault ${id} failed: ${msg}`);
            return {
                patch: {
                    [`${id}_error`]: msg,
                    [`${id}_status`]: { provider, healthy: false }
                }
            };
        }
    }
};

// ============================================================================
// INITIALIZATION & UI
// ============================================================================

const exampleSPC = {
  spc_version: "1.0",
  meta: {
    name: "Demo with Vault",
    exported_at: new Date().toISOString()
  },
  services: {
    "secret-vault": {
      id: "secret-vault",
      type: "vault",
      title: "Secrets Manager",
      spec: {
        provider: "hashicorp-vault",
        secrets: ["api_key", "db_password", "jwt_secret"],
        rotation_policy: {
          interval_hours: 24
        }
      },
      status: "running",
      lastRun: null
    },

    "test-feed": {
      id: "test-feed",
      type: "connector",
      title: "Dummy Data Feed",
      spec: {
        url: "https://jsonplaceholder.typicode.com/todos/1",
        outputKey: "demo_data",
        rules: {
          rules: [{
            name: "extract",
            if: "data",
            then: {
              user: "{{ data.userId }}",
              title: "{{ data.title }}",
              done: "{{ data.completed }}",
              timestamp: "{{ new Date().toISOString() }}"
            }
          }]
        }
      },
      status: "running",
      lastRun: null
    },

    "data-processor": {
      id: "data-processor",
      type: "processor",
      title: "Demo Processor",
      spec: {
        inputKey: "demo_data",
        outputKey: "processed_data",
        transform: [{
          name: "calc",
          if: "data",
          then: {
            message: "{{ data.done ? '‚úÖ Completed' : '‚è≥ Not yet' }}",
            summary: "{{ data.user + ' - ' + data.title }}"
          }
        }]
      },
      status: "running",
      lastRun: null
    },

    "data-monitor": {
      id: "data-monitor",
      type: "monitor",
      title: "Completion Monitor",
      spec: {
        checks: [{
          name: "doneCheck",
          dataKey: "processed_data",
          expression: "data && data.message.includes('‚úÖ')"
        }],
        thresholds: {
          doneCheck: { above: 0 }
        },
        emit: "onChange"
      },
      status: "running",
      lastRun: null
    }
  },
  state: {}
};

function loadExample() {
    window.engine.spc = JSON.parse(JSON.stringify(exampleSPC));
    const editor = document.getElementById('spcEditor');
    if (editor) editor.value = JSON.stringify(window.engine.spc, null, 2);
    window.engine.render();
    window.engine.log('info', 'Example SPC loaded with Vault primitive');
}

function validateSPC() {
    try {
        const editor = document.getElementById('spcEditor');
        const text = editor ? editor.value : '';
        const spc = JSON.parse(text);
        if (!spc.spc_version || !spc.services || !spc.state) {
            throw new Error('Invalid SPC structure (need spc_version, services, state)');
        }
        window.engine.spc = spc;
        window.engine.render();
        window.engine.log('info', 'SPC validated and loaded successfully');
    } catch (error) {
        const msg = error?.message || String(error);
        window.engine.log('error', `Validation failed: ${msg}`);
    }
}

function switchTab(tabName) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    const editor = document.getElementById('spcEditor');
    if (!editor) return;

    switch (tabName) {
        case 'spc':
            editor.value = JSON.stringify(window.engine.spc || exampleSPC, null, 2);
            break;
        case 'schemas':
            editor.value = JSON.stringify({
                connector: "Required: url, outputKey | Optional: rules, cache, schedule",
                processor: "Required: inputKey, outputKey | Optional: transform, pipes",
                monitor: "Required: checks | Optional: thresholds, emit",
                adapter: "Required: kind | Optional: url, body, idempotency_key",
                aggregator: "Required: inputKey, window | Optional: reduce, groupBy",
                vault: "Required: provider | Optional: secrets, rotation_policy"
            }, null, 2);
            break;
        case 'handlers':
            editor.value = `// Handler count by type:
Registered Handlers: ${window.engine.handlers.size}
- connector: ${window.engine.handlers.has('connector') ? '‚úÖ' : '‚ùå'}
- processor: ${window.engine.handlers.has('processor') ? '‚úÖ' : '‚ùå'}
- monitor: ${window.engine.handlers.has('monitor') ? '‚úÖ' : '‚ùå'}
- adapter: ${window.engine.handlers.has('adapter') ? '‚úÖ' : '‚ùå'}
- aggregator: ${window.engine.handlers.has('aggregator') ? '‚úÖ' : '‚ùå'}
- vault: ${window.engine.handlers.has('vault') ? '‚úÖ' : '‚ùå'}

Core Engine Size:
- Engine class: ~50 lines
- Each handler: ~30‚Äì50 lines
- Total: < 400 lines

Micro-kernel + pluggable primitives FTW.
Note: Router primitive has been removed in favor of Vault for secrets management.`;
            break;
    }
}

window.engine = new EDTEngine();

// Register all handlers (vault replaces router)
window.engine.register(connectorHandler);
window.engine.register(processorHandler);
window.engine.register(monitorHandler);
window.engine.register(adapterHandler);
window.engine.register(aggregatorHandler);
window.engine.register(vaultHandler);

window.addEventListener('DOMContentLoaded', () => {
    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const tickBtn = document.getElementById('tickBtn');
    const loadExampleBtn = document.getElementById('loadExampleBtn');
    const validateBtn = document.getElementById('validateBtn');

    if (startBtn) startBtn.addEventListener('click', () => window.engine.start());
    if (stopBtn) stopBtn.addEventListener('click', () => window.engine.stop());
    if (tickBtn) tickBtn.addEventListener('click', () => window.engine.tick());
    if (loadExampleBtn) loadExampleBtn.addEventListener('click', loadExample);
    if (validateBtn) validateBtn.addEventListener('click', validateSPC);

    document.querySelectorAll('.tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
            const tabName = e.target.getAttribute('data-tab');
            switchTab(tabName);
        });
    });

    loadExample();
    window.engine.log('info', 'EDT Micro-Kernel Engine initialized');
    window.engine.log('info', `Registered ${window.engine.handlers.size} primitive handlers (with Vault)`);
});
    </script>
</body>
</html>
